<!doctype html>
<html lang="en">
<head>
  <!-- Performance optimizations for Smartsheet -->
  <link rel="preconnect" href="https://app.smartsheet.eu" crossorigin>
  <link rel="dns-prefetch" href="https://app.smartsheet.eu">
  <link rel="preconnect" href="https://webappassets.smartsheet.eu" crossorigin>
  <link rel="preload" href="https://app.smartsheet.eu/b/publish?EQBCT=d75deb97e5c544d98de6b1b5c4c6f2b6" as="document" fetchpriority="high">
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>NPI Dashboards</title>
  <style>
    :root{
      --philips:#0e5fd8;
      --bar:#0b2b4f;
      --btn:#003366;
      --btnH:#0059b3;
      --btnDis:#7a94b8;
      --warning:#ffcc00;
    }

    html,body{margin:0;height:100%;overflow:hidden;background:#fff;font-family:"Segoe UI","Helvetica Neue",Arial,sans-serif;}

    /* Veil */
    .veil{position:fixed;inset:0;background:#fff;opacity:1;transition:opacity .6s ease;pointer-events:none;z-index:9998;}
    .veil.hidden{opacity:0}

    /* Splash */
    .splash{position:fixed;inset:0;background:var(--philips);z-index:9999;color:#fff}
    .splash-fit{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;text-align:center}
    .splash-inner{display:flex;flex-direction:column;align-items:center;gap:14px}
    .splash-logo{font-weight:900;letter-spacing:.04em;font-size:clamp(66px,14vw,180px);line-height:1.02;white-space:nowrap;
      opacity:0;transform:translateY(14px);
      animation:logoIn .5s ease-out .2s forwards,logoOut .5s ease-in 2.0s forwards;}
    .splash-tag{display:flex;align-items:center;font-size:clamp(28px,3vw,46px);font-weight:700;gap:.35ch;
      opacity:0;transform:translateX(64px);
      animation:tagSlide .8s ease-out .9s forwards,tagFade .5s ease-in 2.0s forwards;}
    /* Center loading line */
    .loading{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;font-weight:800;font-size:clamp(20px,3.6vw,36px);opacity:0;text-align:center;pointer-events:none;white-space:nowrap}
    .loading .dots{display:inline-flex;gap:.28ch;margin-left:.5ch;font-size:0.9em}
    .loading .dots span{opacity:.25;display:inline-block;animation:dotPulse 1s infinite ease-in-out}
    .loading .dots span:nth-child(1){animation-delay:0s}
    .loading .dots span:nth-child(2){animation-delay:.15s}
    .loading .dots span:nth-child(3){animation-delay:.3s}
    @keyframes dotPulse{0%,100%{opacity:.25}50%{opacity:1}}
    .loading{animation:loadingIn .42s cubic-bezier(.22,.9,.35,1) 2.5s forwards}
    @keyframes loadingIn{from{opacity:0;transform:translate(-50%,-55%)}to{opacity:1;transform:translate(-50%,-50%)}}
    @media (max-width:420px){.loading{font-size:clamp(18px,5.5vw,28px)}}

    .sparkles{position:relative;width:1.25em;height:1.25em;display:inline-block;margin:0 .08em}
    .sparkles svg{position:absolute;inset:0;width:100%;height:100%;fill:#fff}
    .sparkles .back{opacity:.45;transform:translate(.18em,-.14em) scale(.78)}
    .sparkles .front{opacity:1}
    .splash.fade-out{animation:fadeSplash .8s ease-in forwards}

    @keyframes logoIn{to{opacity:1;transform:translateY(0)}}
    @keyframes logoOut{to{opacity:0;transform:translateY(-20px)}}
    @keyframes tagSlide{to{opacity:1;transform:translateX(0)}}
    @keyframes tagFade{to{opacity:0;transform:translateX(-20px)}}
    @keyframes fadeSplash{to{opacity:0;visibility:hidden}}

    .sparkles{position:relative;width:1.25em;height:1.25em;display:inline-block;margin:0 .08em}
    .sparkles svg{position:absolute;inset:0;width:100%;height:100%;fill:#fff}
    .sparkles .back{opacity:.45;transform:translate(.18em,-.14em) scale(.78)}
    .sparkles .front{opacity:1}
    .splash.fade-out{animation:fadeSplash .8s ease-in forwards}

    @keyframes logoIn{to{opacity:1;transform:translateY(0)}}
    @keyframes logoOut{to{opacity:0;transform:translateY(-20px)}}
    @keyframes tagSlide{to{opacity:1;transform:translateX(0)}}
    @keyframes tagFade{to{opacity:0;transform:translateX(-20px)}}
    @keyframes fadeSplash{to{opacity:0;visibility:hidden}}

    /* Refresh Status Box */
    .refresh-status {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 200px;
      background: var(--bar);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      color: white;
      z-index: 9999;
      padding: 12px;
      display: none;
      font-size: 13px;
      cursor: move;
      user-select: none;
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }

    .refresh-status.active {
      display: block;
      opacity: 1;
    }

    .status-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .status-message {
      margin-bottom: 8px;
      font-weight: 500;
    }

    .time-remaining {
      color: rgba(255,255,255,0.9);
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 12px;
    }
    .status-header .btn.cancel{
      background: #c0392b;
      color: #fff;
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      border: 0;
      margin-left: 8px;
      cursor: pointer;
    }
    .status-header .btn.cancel:hover{background:#e74c3c}
    .time-num{font-weight:700}

    /* Toast notification */
    .toast-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--bar);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: none;
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
    }

    .toast-notification.show {
      display: block;
    }

    .progress-container {
      width: 100%;
      height: 4px;
      background: #eee;
      border-radius: 2px;
      overflow: hidden;
      margin: 15px 0;
    }

    .progress-bar {
      width: 0%;
      height: 100%;
      background: var(--philips);
      transition: width 5s linear; /* smoother, slower transition (now 5s) */
    }

    .status-footer {
      text-align: center;
      color: #666;
      font-size: 13px;
    }

    /* Disable buttons during update */
    .refresh-button.disabled,
    .export-button.disabled,
    .edit-button.disabled {
      opacity: 0.5;
      pointer-events: none;
      cursor: not-allowed;
    }

    /* Top bar and Navigation */
    .top{
      position:fixed;
      inset:0 0 auto 0;
      height:56px;
      display:flex;
      gap:10px;
      align-items:center;
      padding:0 14px;
      background:var(--bar);
      color:#fff;
      z-index:100;
      opacity:0;
      transition:opacity 1s ease
    }

    /* Dropdown Menu */
    .nav-item {
      position: relative;
      display: inline-block;
    }

    .dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--bar);
      border-radius: 8px;
      padding: 8px;
      min-width: 220px;
      box-shadow: 0 4px 12px rgba(0,0,0,.2);
      z-index: 1000;
      margin-top: 2px;
    }

    /* Add padding to create hoverable area between button and dropdown */
    .nav-item::after {
      content: '';
      position: absolute;
      height: 10px;
      left: 0;
      right: 0;
      bottom: -10px;
    }

    /* Show dropdown on hover and keep it visible while hovering the gap */
    .nav-item:hover .dropdown {
      display: block;
      animation: fadeIn 0.1s ease-out;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      transition: background .15s ease-in-out;
      font-weight: 500;
      white-space: nowrap;
    }

    .dropdown-item:hover {
      background: var(--btnH);
    }

    .dropdown-item svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
      flex-shrink: 0;
    }

    .dropdown-item.refresh-button {
      color: var(--warning);
    }

    .dropdown-item.export-button {
      color: #4CAF50;
    }

    .dropdown-item.export-button:hover {
      background: #4CAF50;
      color: white;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .btn{display:inline-block;border:0;border-radius:12px;padding:8px 14px;font-weight:700;color:#fff;background:#104071;text-decoration:none}
    .btn{transition:transform .12s ease, box-shadow .12s ease, background-color .12s ease}
    .btn:active{transform:translateY(1px) scale(.995); box-shadow:inset 0 2px 6px rgba(0,0,0,.25); background:var(--btnH)}
    .top a.btn:hover{background:var(--btnH)}
    .top a.btn.selected{background:#fff;color:var(--bar);box-shadow:0 6px 20px rgba(0,0,0,.18)}

    /* Stage */
    .stage{position:absolute;inset:56px 0 0 0;opacity:0;transition:opacity .6s ease}
    iframe{width:100%;height:100%;border:0;background:#fff}
    .slide {
      overflow-y: auto;
      overflow-x: hidden;
    }
    .slide img {
      width: 100%;
      height: auto;
      display: block;
      background: #fff;
    }

    /* Project containers */
    .project{position:absolute;inset:0;transition:opacity .3s ease}
    .project.inactive{opacity:0;z-index:0;pointer-events:none}
    .project.active{opacity:1;z-index:1;pointer-events:auto}

    /* Slider */
    .slides{position:absolute;inset:0}
    .slide{
      position:absolute;
      inset:0;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.3s ease;
      height: 100%;
      overflow-y: auto;
    }
    .slide.active{
      opacity:1;
      pointer-events:auto;
      z-index:1;
    }
    .controls{position:absolute;left:0;right:0;bottom:18px;display:flex;justify-content:space-between;align-items:center;padding:0 22px;z-index:30}
    .controls .btn{padding:10px 16px;font-size:14px;background:var(--btn)}
    .controls .btn:hover{background:var(--btnH)}
    .controls .btn[disabled]{background:var(--btnDis);cursor:not-allowed;opacity:.65}
    .counter{color:#fff;background:rgba(0,0,0,.35);padding:6px 10px;border-radius:8px;font-weight:700}
  </style>
  
  <!-- Export Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
</head>
<body>
  <!-- Refresh Status Box -->
  <div id="refresh-status" class="refresh-status" aria-live="polite">
    <div class="status-header">
      <span class="drag-handle">⋮⋮</span>
      <div class="time-remaining"><span class="time-display">10:00</span></div>
      <button id="cancel-update" class="btn cancel" title="Cancel update">Cancel</button>
    </div>
    <div class="status-message">Initializing update...</div>
    <div class="progress-container">
      <div class="progress-bar"></div>
    </div>
  </div>

  <!-- SPLASH -->
  <div id="splash" class="splash">
    <div class="splash-fit">
      <div class="splash-inner">
        <div class="splash-logo">PHILIPS</div>
        <div class="splash-tag">
          <span>innovation</span>
          <span class="sparkles">
            <svg class="back" viewBox="0 0 24 24"><path d="M12 2l1.8 5.4L19 9.5l-5.2 1.7L12 16l-1.8-4.8L5 9.5l5.2-2.1L12 2z"/></svg>
            <svg class="front" viewBox="0 0 24 24"><path d="M12 2l1.8 5.4L19 9.5l-5.2 1.7L12 16l-1.8-4.8L5 9.5l5.2-2.1L12 2z"/></svg>
          </span>
          <span>you</span>
        </div>
        <div id="splash-loading" class="loading" aria-hidden="true">
          <span>Loading NPI Dashboards</span>
          <span class="dots"><span>.</span><span>.</span><span>.</span></span>
        </div>
      </div>
    </div>
  </div>
  <div class="veil" id="veil"></div>

  <!-- NAVIGATION -->
  <div class="top" id="topbar">
    <a class="btn" href="#home" data-route="home">Home</a>
    
    <div class="nav-item">
      <a class="btn" href="#vm13" data-route="vm13">VM 13.0</a>
      <div class="dropdown">
  <a class="dropdown-item refresh-button" href="#" onclick="refreshDashboards('VM 13.0')">
          <svg viewBox="0 0 24 24"><path d="M17.65 6.35A7.958 7.958 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
          Refresh Dashboards
        </a>
        <a class="dropdown-item export-button" href="#" onclick="saveAsPDF('VM 13.0')">
          <svg viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>
          Save as PDF
        </a>
        <a class="dropdown-item export-button" href="#" onclick="saveAsPPT('VM 13.0')">
          <svg viewBox="0 0 24 24"><path d="M9.8,13.4H8.7V10.5H9.8C10.6,10.5 11.2,11.1 11.2,12C11.2,12.9 10.6,13.4 9.8,13.4M23,7V17A2,2 0 0,1 21,19H3A2,2 0 0,1 1,17V7A2,2 0 0,1 3,5H21A2,2 0 0,1 23,7M7.8,15.5H10.2C11.8,15.5 13,14.3 13,12.5C13,10.7 11.8,9.5 10.2,9.5H7.8V15.5M15.1,15.5H16.3V13.3H17.9C18.7,13.3 19.3,12.7 19.3,11.9C19.3,11.1 18.7,10.5 17.9,10.5H15.1V15.5M16.3,12.3V11.5H17.7V12.3H16.3Z"/></svg>
          Save as PowerPoint
        </a>
        <a class="dropdown-item edit-button" href="https://app.smartsheet.eu/workspaces/W7JvM9F6XMVhxv7ffw4rVJfg4CM7xgfxjPC5JHf1" target="_blank">
          <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
          Edit Data
        </a>
      </div>
    </div>

    <div class="nav-item">
      <a class="btn" href="#blaze" data-route="blaze">Blaze 1.0</a>
      <div class="dropdown">
  <a class="dropdown-item refresh-button" href="#" onclick="refreshDashboards('Blaze 1.0')">
          <svg viewBox="0 0 24 24"><path d="M17.65 6.35A7.958 7.958 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
          Refresh Dashboards
        </a>
        <a class="dropdown-item export-button" href="#" onclick="saveAsPDF('Blaze 1.0')">
          <svg viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>
          Save as PDF
        </a>
        <a class="dropdown-item export-button" href="#" onclick="saveAsPPT('Blaze 1.0')">
          <svg viewBox="0 0 24 24"><path d="M9.8,13.4H8.7V10.5H9.8C10.6,10.5 11.2,11.1 11.2,12C11.2,12.9 10.6,13.4 9.8,13.4M23,7V17A2,2 0 0,1 21,19H3A2,2 0 0,1 1,17V7A2,2 0 0,1 3,5H21A2,2 0 0,1 23,7M7.8,15.5H10.2C11.8,15.5 13,14.3 13,12.5C13,10.7 11.8,9.5 10.2,9.5H7.8V15.5M15.1,15.5H16.3V13.3H17.9C18.7,13.3 19.3,12.7 19.3,11.9C19.3,11.1 18.7,10.5 17.9,10.5H15.1V15.5M16.3,12.3V11.5H17.7V12.3H16.3Z"/></svg>
          Save as PowerPoint
        </a>
        <a class="dropdown-item edit-button" href="https://app.smartsheet.eu/workspaces/MP68x2GxfFg79xcqvJhFw5hjhGQQ9j7G5G3QXQh1" target="_blank">
          <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
          Edit Data
        </a>
      </div>
    </div>

    <div class="nav-item">
      <a class="btn" href="#vm14" data-route="vm14">VM 14.0</a>
      <div class="dropdown">
  <a class="dropdown-item refresh-button" href="#" onclick="refreshDashboards('VM 14.0')">
          <svg viewBox="0 0 24 24"><path d="M17.65 6.35A7.958 7.958 0 0 0 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0 1 12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
          Refresh Dashboards
        </a>
        <a class="dropdown-item export-button" href="#" onclick="saveAsPDF('VM 14.0')">
          <svg viewBox="0 0 24 24"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>
          Save as PDF
        </a>
        <a class="dropdown-item export-button" href="#" onclick="saveAsPPT('VM 14.0')">
          <svg viewBox="0 0 24 24"><path d="M9.8,13.4H8.7V10.5H9.8C10.6,10.5 11.2,11.1 11.2,12C11.2,12.9 10.6,13.4 9.8,13.4M23,7V17A2,2 0 0,1 21,19H3A2,2 0 0,1 1,17V7A2,2 0 0,1 3,5H21A2,2 0 0,1 23,7M7.8,15.5H10.2C11.8,15.5 13,14.3 13,12.5C13,10.7 11.8,9.5 10.2,9.5H7.8V15.5M15.1,15.5H16.3V13.3H17.9C18.7,13.3 19.3,12.7 19.3,11.9C19.3,11.1 18.7,10.5 17.9,10.5H15.1V15.5M16.3,12.3V11.5H17.7V12.3H16.3Z"/></svg>
          Save as PowerPoint
        </a>
        <a class="dropdown-item edit-button" href="https://app.smartsheet.eu/workspaces/gM9wv3Rqwphqjj6hj4gHrGfPmrJWMFhhfCf7X6G1" target="_blank">
          <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
          Edit Data
        </a>
      </div>
    </div>
    
    <div class="spacer"></div>
  </div>

  <!-- DASHBOARDS -->
  <div class="stage" id="stage">
    <!-- HOME - Live URL -->
    <div id="view-home" class="project active">
      <iframe 
        src="https://app.smartsheet.eu/b/publish?EQBCT=d75deb97e5c544d98de6b1b5c4c6f2b6" 
        loading="eager" 
        fetchpriority="high"
        importance="high"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope"
        sandbox="allow-scripts allow-same-origin allow-popups"
        referrerpolicy="no-referrer"></iframe>
    </div>

    <!-- VM13 -->
    <div id="view-vm13" class="project inactive">
      <div class="slides">
        <div class="slide active"><img src="snapshots/2025-09/VM 13.0/Dashboard-1.png" alt="VM13 Dashboard 1" loading="eager"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 13.0/Dashboard-2.png" alt="VM13 Dashboard 2"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 13.0/Dashboard-3.png" alt="VM13 Dashboard 3"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 13.0/Dashboard-4.png" alt="VM13 Dashboard 4"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 13.0/Dashboard-5.png" alt="VM13 Dashboard 5"></div>
      </div>
      <div class="controls"><button class="btn prev">⟨ Prev</button><div class="counter">1 / 5</div><button class="btn next">Next ⟩</button></div>
    </div>

    <!-- Blaze -->
    <div id="view-blaze" class="project inactive">
      <div class="slides">
        <div class="slide active"><img src="snapshots/2025-09/Blaze 1.0/Dashboard-1.png" alt="Blaze Dashboard 1" loading="eager"></div>
        <div class="slide"><img src="snapshots/2025-09/Blaze 1.0/Dashboard-2.png" alt="Blaze Dashboard 2"></div>
        <div class="slide"><img src="snapshots/2025-09/Blaze 1.0/Dashboard-3.png" alt="Blaze Dashboard 3"></div>
        <div class="slide"><img src="snapshots/2025-09/Blaze 1.0/Dashboard-4.png" alt="Blaze Dashboard 4"></div>
      </div>
      <div class="controls"><button class="btn prev">⟨ Prev</button><div class="counter">1 / 4</div><button class="btn next">Next ⟩</button></div>
    </div>

    <!-- VM14 -->
    <div id="view-vm14" class="project inactive">
      <div class="slides">
        <div class="slide active"><img src="snapshots/2025-09/VM 14.0/Dashboard-1.png" alt="VM14 Dashboard 1" loading="eager"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 14.0/Dashboard-2.png" alt="VM14 Dashboard 2"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 14.0/Dashboard-3.png" alt="VM14 Dashboard 3"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 14.0/Dashboard-4.png" alt="VM14 Dashboard 4"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 14.0/Dashboard-5.png" alt="VM14 Dashboard 5"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 14.0/Dashboard-6.png" alt="VM14 Dashboard 6"></div>
        <div class="slide"><img src="snapshots/2025-09/VM 14.0/Dashboard-7.png" alt="VM14 Dashboard 7"></div>
      </div>
      <div class="controls"><button class="btn prev">⟨ Prev</button><div class="counter">1 / 7</div><button class="btn next">Next ⟩</button></div>
    </div>
  </div>

 <script>
  // Constants  
  const WORKFLOW_PAT_NEW = '${{ secrets.WORKFLOW_PAT_NEW }}';  // Will be replaced during build
  const SPLASH_TIMEOUT = 2500;  // Maximum splash screen wait time
  
  const ROUTES = ['home', 'vm13', 'blaze', 'vm14'];
  const CONTAINERS = ROUTES.reduce((acc, route) => {
    acc[route] = document.getElementById(`view-${route}`);
    return acc;
  }, {});

  let currentSliders = {};

  function show(route){
    ROUTES.forEach(r=>{
      const el=CONTAINERS[r];if(!el)return;
      if(r===route){
        el.classList.add('active');
        el.classList.remove('inactive');
        // Initialize slider for this route if it hasn't been yet
        if(r !== 'home' && !currentSliders[r]) {
          setupSlider(el);
        }
      } else {
        el.classList.remove('active');
        el.classList.add('inactive');
      }
    });
    if(location.hash.replace('#','')!==route)location.hash=route;
  }



  function setupSlider(project) {
    if (project.id === 'view-home') return;
    
    const slides = Array.from(project.querySelectorAll('.slide'));
    const [prev, next] = project.querySelectorAll('.btn');
    const counter = project.querySelector('.counter');
    if (!slides.length) return;

    let currentIndex = 0;

    function updateSlides() {
      slides.forEach((s, i) => s.classList.toggle('active', i === currentIndex));
      counter.textContent = `${currentIndex + 1} / ${slides.length}`;
      prev.disabled = currentIndex === 0;
      next.disabled = currentIndex === slides.length - 1;
    }

    prev.onclick = () => {
      if (currentIndex > 0) {
        currentIndex--;
        updateSlides();
      }
    };

    next.onclick = () => {
      if (currentIndex < slides.length - 1) {
        currentIndex++;
        updateSlides();
      }
    };

    updateSlides();
    currentSliders[project.id.replace('view-', '')] = { currentIndex, slides };
  }

  function setupSliders() {
    document.querySelectorAll('.project').forEach(setupSlider);
  }

  // Initialize on page load
  window.addEventListener('load', () => {
    const splash = document.getElementById('splash');
    const veil = document.getElementById('veil');
    const topbar = document.getElementById('topbar');
    const stage = document.getElementById('stage');
    const homeIframe = document.querySelector('#view-home iframe');

    function showUI() {
      veil?.classList.add('hidden');
      topbar.style.opacity = '1';
      stage.style.opacity = '1';
    }

    function removeSplash() {
      splash?.classList.add('fade-out');
      setTimeout(() => {
        splash?.remove();
        veil?.remove();
        showUI();
      }, 400);
    }

    // Handle home iframe load
    if (homeIframe) {
      homeIframe.addEventListener('load', removeSplash, { once: true });
    }

    // Fallback
    setTimeout(removeSplash, SPLASH_TIMEOUT);

    // Set initial route
    const initialRoute = location.hash.slice(1) || 'home';
    updateNavSelection(initialRoute);
    setupSliders();
  });

  function updateNavSelection(route){
    document.querySelectorAll('.top a.btn[data-route]').forEach(a=>{
      const is = a.dataset.route===route;
      a.classList.toggle('selected', is);
      if(is) a.setAttribute('aria-current','page'); else a.removeAttribute('aria-current');
    });
  }

  document.querySelectorAll('.top a.btn[data-route]').forEach(a=>{
    a.addEventListener('click',e=>{
      e.preventDefault();
      show(a.dataset.route);
      updateNavSelection(a.dataset.route);
    });
  });

  window.addEventListener('hashchange',()=>{
    const r=(location.hash||'#home').replace('#','');
    const route = ROUTES.includes(r)?r:'home';
    show(route);
    updateNavSelection(route);
  });

  function showDashboard(project) {
    show(project);
    updateNavSelection(project);
  }

  // Global updateState so cancel handler can access
  let updateState = null;

  // Project dashboard configurations
  const DASHBOARD_COUNTS = {
    'VM 13.0': 5,
    'Blaze 1.0': 4,
    'VM 14.0': 7
  };

  async function saveAsPDF(projectName) {
    // Comprehensive validation
    if (!projectName || typeof projectName !== 'string') {
      alert('Please select a valid project first');
      return;
    }
    
    // Check if libraries are loaded
    if (!window.jspdf) {
      alert('PDF library not loaded. Please refresh the page.');
      return;
    }
    
    // Prevent multiple simultaneous exports
    if (window.exportInProgress) {
      alert('Export already in progress. Please wait.');
      return;
    }
    
    // Prevent export during refresh operations
    if (window.updateState && !window.updateState.isCompleted) {
      alert('Cannot export while refresh is in progress. Please wait for refresh to complete.');
      return;
    }
    
    window.exportInProgress = true;
    
    // Disable save buttons to prevent multiple clicks
    document.querySelectorAll('.export-button').forEach(btn => btn.style.pointerEvents = 'none');
    
    const statusBox = document.getElementById('refresh-status');
    const messageEl = statusBox.querySelector('.status-message');
    
    // Validate UI elements exist
    if (!statusBox || !messageEl) {
      console.error('Required UI elements not found');
      window.exportInProgress = false;
      return;
    }
    
    statusBox.classList.add('active');
    const timeRemaining = statusBox.querySelector('.time-remaining');
    const progressContainer = statusBox.querySelector('.progress-container');
    const cancelButton = statusBox.querySelector('#cancel-update');
    
    if (timeRemaining) timeRemaining.style.display = 'none';
    if (progressContainer) progressContainer.style.display = 'none';
    if (cancelButton) cancelButton.style.display = 'none';
    messageEl.textContent = '⏳ Generating PDF...';
    
    try {
      // Get dashboard images
      const images = await getDashboardImages(projectName);
      
      if (images.length === 0) {
        throw new Error('No dashboard images found');
      }
      
      // Create PDF using jsPDF
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({
        orientation: 'landscape',
        unit: 'mm',
        format: 'a4'
      });
      
      // Title page with blue background (matching PowerPoint)
      doc.setFillColor(14, 95, 216); // Philips blue background
      doc.rect(0, 0, 297, 210, 'F'); // Fill entire page with blue
      
      doc.setFontSize(24);
      doc.setTextColor(255, 255, 255); // White text on blue background
      doc.text(projectName, 20, 30);
      
      doc.setFontSize(16);
      doc.setTextColor(255, 255, 255); // White text
      doc.text('Dashboard Report', 20, 50);
      
      doc.setFontSize(12);
      doc.setTextColor(220, 220, 220); // Light gray text for details
      doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 70);
      doc.text(`Total Dashboards: ${images.length}`, 20, 80);
      

      
    // Add each dashboard image - full page, no titles
    for (let i = 0; i < images.length; i++) {
      doc.addPage();
      
      try {
        // Simple image fitting - resize to fit page dimensions
        const pageWidth = 297;  // A4 width in mm
        const pageHeight = 210; // A4 height in mm
        const margin = 15;      // 15mm margin
        const imgWidth = pageWidth - (margin * 2);   // 267mm width
        const imgHeight = pageHeight - (margin * 2);  // 180mm height
        
        // Compress image if it's too large to prevent "Invalid String Length" error
        let imageData = images[i];
        if (imageData.length > 1500000) { // If image is larger than 1.5MB
          // Create a compressed version
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();
          
          await new Promise((resolve) => {
            img.onload = () => {
              // Reduce size to prevent memory issues
              const maxWidth = 1800;
              const maxHeight = 1200;
              let { width, height } = img;
              
              if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width *= ratio;
                height *= ratio;
              }
              
              canvas.width = width;
              canvas.height = height;
              ctx.drawImage(img, 0, 0, width, height);
              imageData = canvas.toDataURL('image/jpeg', 0.7);
              resolve();
            };
            img.src = images[i];
          });
        }
        
        // Add image resized to fit page
        doc.addImage(imageData, imageData.includes('jpeg') ? 'JPEG' : 'PNG', margin, margin, imgWidth, imgHeight);
        

        
      } catch (err) {
        console.warn(`Error adding image ${i + 1}:`, err);
        doc.setFontSize(12);
        doc.setTextColor(204, 0, 0);
        doc.text(`Error loading dashboard image ${i + 1}`, 20, 105); // Center vertically
      }
    }      // Save the PDF
      const timestamp = new Date().toISOString().slice(0, 10);
      const filename = `${projectName.replace(/\s+/g, '_')}_Dashboard_Report_${timestamp}.pdf`;
      
      doc.save(filename);
      
      messageEl.textContent = `✅ PDF saved successfully`;
      setTimeout(() => statusBox.classList.remove('active'), 3000);
      
    } catch (error) {
      console.error('PDF generation failed:', error);
      messageEl.textContent = `❌ PDF generation failed: ${error.message}`;
      setTimeout(() => statusBox.classList.remove('active'), 5000);
    } finally {
      // Clean up PDF export state
      window.exportInProgress = false;
      
      // Re-enable save buttons (don't restore time/cancel - those are for refresh only)
      try {
        document.querySelectorAll('.export-button').forEach(btn => btn.style.pointerEvents = 'auto');
      } catch (error) {
        console.error('Error during PDF cleanup:', error);
      }
    }
  }

  async function saveAsPPT(projectName) {
    if (!projectName) {
      alert('Please select a project first');
      return;
    }
    
    // Check if libraries are loaded
    if (!window.PptxGenJS) {
      alert('PowerPoint library not loaded. Please refresh the page.');
      return;
    }
    
    // Prevent multiple simultaneous exports
    if (window.exportInProgress) {
      alert('Export already in progress. Please wait.');
      return;
    }
    
    // Prevent export during refresh operations
    if (window.updateState && !window.updateState.isCompleted) {
      alert('Cannot export while refresh is in progress. Please wait for refresh to complete.');
      return;
    }
    
    window.exportInProgress = true;
    
    // Disable save buttons to prevent multiple clicks
    document.querySelectorAll('.export-button').forEach(btn => btn.style.pointerEvents = 'none');
    
    const statusBox = document.getElementById('refresh-status');
    const messageEl = statusBox.querySelector('.status-message');
    
    // Validate UI elements exist
    if (!statusBox || !messageEl) {
      console.error('Required UI elements not found');
      window.exportInProgress = false;
      return;
    }
    
    statusBox.classList.add('active');
    const timeRemaining = statusBox.querySelector('.time-remaining');
    const progressContainer = statusBox.querySelector('.progress-container');
    const cancelButton = statusBox.querySelector('#cancel-update');
    
    if (timeRemaining) timeRemaining.style.display = 'none';
    if (progressContainer) progressContainer.style.display = 'none';
    if (cancelButton) cancelButton.style.display = 'none';
    messageEl.textContent = '⏳ Generating PowerPoint...';
    
    try {
      const images = await getDashboardImages(projectName);
      
      if (images.length === 0) {
        throw new Error('No dashboard images found for this project');
      }

      // Create new presentation
      let pptx = new PptxGenJS();
      pptx.layout = 'LAYOUT_WIDE'; // 10" x 7.5"
      pptx.author = 'Philips NPI Dashboards';
      pptx.company = 'Philips';
      pptx.subject = `${projectName} Dashboard Report`;
      pptx.title = `${projectName} Dashboards`;
      
      // Add title slide
      let titleSlide = pptx.addSlide();
      titleSlide.background = { color: '0e5fd8' }; // Philips blue
      
      titleSlide.addText(projectName, {
        x: 1, y: 2, w: 8, h: 1.5,
        fontSize: 36, bold: true, color: 'ffffff'
      });
      
      titleSlide.addText('Dashboard Report', {
        x: 1, y: 3.5, w: 8, h: 1,
        fontSize: 24, color: 'ffffff'
      });
      
      titleSlide.addText(`Generated: ${new Date().toLocaleDateString()}`, {
        x: 1, y: 5, w: 8, h: 0.5,
        fontSize: 14, color: 'cccccc'
      });
      
      titleSlide.addText(`Total Dashboards: ${images.length}`, {
        x: 1, y: 5.5, w: 8, h: 0.5,
        fontSize: 14, color: 'cccccc'
      });
      

      
      // Add each dashboard as a slide with navigation
      for (let i = 0; i < images.length; i++) {
        let slide = pptx.addSlide();
        slide.background = { color: 'ffffff' };
        

        
        try {
          // Extend images even more - stretch to 14" width
          slide.addImage({
            data: images[i],
            x: 0,      // Start at left edge
            y: 0,      // Start at top edge  
            w: 14,     // Extended width (14" - much wider than 10" slide)
            h: 7.5     // Full slide height (7.5")
          });
        } catch (err) {
          console.warn(`Error adding slide ${i + 1}:`, err);
          // Only show error text if image fails - center it
          slide.addText(`Error loading dashboard image`, {
            x: 1, y: 3.5, w: 8, h: 1,
            fontSize: 24, color: 'ff0000',
            align: 'center'
          });
        }
      }
      
      // Save the PowerPoint
      const timestamp = new Date().toISOString().slice(0, 10);
      const filename = `${projectName.replace(/\s+/g, '_')}_Dashboard_Report_${timestamp}.pptx`;
      
      await pptx.writeFile({ fileName: filename });
      
      messageEl.textContent = `✅ PowerPoint saved successfully`;
      setTimeout(() => statusBox.classList.remove('active'), 3000);
      
    } catch (error) {
      console.error('PowerPoint generation failed:', error);
      messageEl.textContent = `❌ PowerPoint generation failed: ${error.message}`;
      setTimeout(() => statusBox.classList.remove('active'), 5000);
    } finally {
      // Clean up PowerPoint export state
      window.exportInProgress = false;
      
      // Re-enable save buttons and restore UI
      try {
        document.querySelectorAll('.export-button').forEach(btn => btn.style.pointerEvents = 'auto');
      } catch (error) {
        console.error('Error during PowerPoint cleanup:', error);
      }
    }
  }



  function cancelExport() {
    try {
      // Clean up export state
      window.exportInProgress = false;
      
      // Re-enable save buttons
      document.querySelectorAll('.export-button').forEach(btn => {
        if (btn) btn.style.pointerEvents = 'auto';
      });
      
      // Hide status box (don't restore time/cancel - those are for refresh only)
      const statusBox = document.getElementById('refresh-status');
      if (statusBox) {
        statusBox.classList.remove('active');
      }
    } catch (error) {
      console.error('Error during cancel:', error);
      // Force cleanup even if there's an error
      window.exportInProgress = false;
    }
  }

  async function getDashboardImages(projectName) {
    // Validate input
    if (!projectName || typeof projectName !== 'string') {
      throw new Error('Invalid project name provided');
    }
    
    const images = [];
    const dashboardCount = DASHBOARD_COUNTS[projectName];
    
    if (!dashboardCount) {
      throw new Error(`Project "${projectName}" not found in dashboard configuration`);
    }
    
    if (dashboardCount <= 0) {
      throw new Error(`No dashboards configured for project "${projectName}"`);
    }
    
    try {
      // Try to load images from snapshots directory structure
      for (let i = 1; i <= dashboardCount; i++) {
        try {
          // Try current month first, then fallback to previous months
          const currentDate = new Date();
          const monthFolder = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
          const imagePath = `snapshots/${monthFolder}/${projectName}/Dashboard-${i}.png`;
          
          const imageData = await loadImageAsBase64(imagePath);
          if (imageData) {
            images.push(imageData);
          }
        } catch (err) {
          console.warn(`Could not load dashboard ${i}:`, err);
        }
      }
      
      return images;
      
    } catch (error) {
      console.error('Error getting dashboard images:', error);
      return [];
    }
  }

  async function loadImageAsBase64(imagePath) {
    return new Promise((resolve, reject) => {
      // Validate input
      if (!imagePath || typeof imagePath !== 'string') {
        reject(new Error('Invalid image path provided'));
        return;
      }
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      
      // Set timeout for image loading
      const timeout = setTimeout(() => {
        reject(new Error(`Image loading timeout: ${imagePath}`));
      }, 30000); // 30 second timeout
      
      img.onload = function() {
        clearTimeout(timeout);
        
        try {
          // Validate image dimensions
          if (!img.naturalWidth || !img.naturalHeight) {
            reject(new Error(`Invalid image dimensions: ${imagePath}`));
            return;
          }
          
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          if (!ctx) {
            reject(new Error('Failed to create canvas context'));
            return;
          }
          
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          ctx.drawImage(img, 0, 0);
          
          const dataUrl = canvas.toDataURL('image/png');
          if (!dataUrl || dataUrl === 'data:,') {
            reject(new Error(`Failed to convert image to base64: ${imagePath}`));
            return;
          }
          
          resolve(dataUrl);
        } catch (error) {
          clearTimeout(timeout);
          reject(new Error(`Canvas processing failed: ${error.message}`));
        }
      };
      
      img.onerror = function(error) {
        clearTimeout(timeout);
        reject(new Error(`Failed to load image: ${imagePath} - ${error.message || 'Unknown error'}`));
      };
      
      img.src = imagePath;
    });
  }

  async function refreshDashboards(project) {
    const statusBox = document.getElementById('refresh-status');
    const messageEl = statusBox.querySelector('.status-message');
    const progressBar = statusBox.querySelector('.progress-bar');
    const timeNum = statusBox.querySelector('.time-num');
    const statusFooter = statusBox.querySelector('.status-footer');
    
    // If an update is already running, don't start another
    if (updateState && !updateState.isCompleted) {
      showToast('Update already in progress');
      return;
    }

    // Disable all refresh buttons
    document.querySelectorAll('.refresh-button').forEach(btn => {
      btn.classList.add('disabled');
    });
    
    // Disable export buttons during refresh to prevent conflicts
    document.querySelectorAll('.export-button').forEach(btn => {
      btn.classList.add('disabled');
      btn.style.pointerEvents = 'none';
    });
    
    // Disable edit buttons during refresh to prevent data conflicts
    document.querySelectorAll('.edit-button').forEach(btn => {
      btn.classList.add('disabled');
      btn.style.pointerEvents = 'none';
    });

    statusBox.classList.add('active');

    // Initialize update state
    updateState = {
      startTime: Date.now(),
      totalTime: 12 * 60 * 1000, // 11 minutes (so UI shows 10 mins remaining initially)
      isCompleted: false,
      timer: null,
      runId: null,
      project: project,
      dispatchTime: null,
      lastProgress: 0,
      lastMessage: null,
      lastMessageTime: 0,
      fiveSecondNotified: false
    };

    // Immediately show full time so UI shows 10 right away
    const timeNumEl = statusBox.querySelector('.time-num');
    const timeLabelEl = statusBox.querySelector('.time-label');
    if (timeNumEl) { timeNumEl.textContent = Math.ceil(updateState.totalTime / 60000); }
    if (timeLabelEl) { timeLabelEl.textContent = 'min remaining'; }

    // Check for existing workflow
    const workflowKey = 'current_workflow_update';
    const existingWorkflow = localStorage.getItem(workflowKey);
    
    if (existingWorkflow) {
      const workflowData = JSON.parse(existingWorkflow);
      const isRecent = Date.now() - workflowData.timestamp < 600000; // 10 minutes
      
      if (isRecent) {
        updateState.startTime = workflowData.timestamp;
        updateState.currentStep = workflowData.step || 0;
        messageEl.textContent = 'Resuming update...';
        statusFooter.textContent = `Continuing update for ${workflowData.project}`;
      } else {
        localStorage.removeItem(workflowKey);
      }
    }

    // Update messages for different stages of the process
    // Messages evenly spaced across the 10-minute window
    // 20 messages, each will show for ~30s across the 10-minute window
    const updateMessages = [
      'Initializing workflow',
      'Preparing environment',
      'Authenticating with services',
      'Starting capture engine',
      'Loading dashboard templates',
      'Opening dashboard pages',
      'Warming up renderers',
      'Capturing dashboard 1',
      'Capturing dashboard 2',
      'Capturing dashboard 3',
      'Capturing dashboard 4',
      'Processing captured images',
      'Optimizing screenshots',
      'Combining assets',
      'Updating dashboard visuals',
      'Preparing commit',
      'Committing changes',
      'Pushing updates',
      'Finalizing update',
      'Cleaning up and finishing'
    ];

    const updateProgress = (percent, message, timeLeft, opts = {}) => {
      // Update progress bar
      // Progress driven by time (percent) directly for smoothness
      progressBar.style.width = `${percent}%`;
      
      // Show one-time 5-second warning message before refresh
      if (typeof timeLeft === 'number' && timeLeft <= 5000 && updateState && !updateState.fiveSecondNotified) {
        message = 'Finishing — page will refresh in 5s';
        updateState.fiveSecondNotified = true;
        // allow immediate message update
        updateState.lastMessageTime = 0;
      }

      // Update message with debounce to avoid rapid flicker
      // Update message based on percent if not provided explicitly
      if (!message) {
        // If message is not provided, pick one based on elapsed time so each stays ~30s
        const elapsedForMsg = (updateState && updateState.startTime) ? (Date.now() - updateState.startTime) : 0;
        const idx = Math.min(updateMessages.length - 1, Math.floor(elapsedForMsg / 30000));
        message = updateMessages[idx];
      }
      // Debounce updates slightly to avoid flicker
      const now = Date.now();
      if (message && (now - (updateState.lastMessageTime || 0) > 700 || message !== updateState.lastMessage)) {
        messageEl.textContent = message;
        updateState.lastMessage = message;
        updateState.lastMessageTime = now;
      }
      
  // Update time: show whole minutes only until 2 minutes remain, then show MM:SS
      if (typeof timeLeft === 'number') {
        const twoMinutesMs = 2 * 60 * 1000;
        const label = statusBox.querySelector('.time-display');
        if (label) {
          if (timeLeft > twoMinutesMs) {
            // Show whole number of minutes but display one less so it reads like "9 mins remaining" at start
            const mins = Math.max(1, Math.ceil(timeLeft / 60000) - 1);
            label.textContent = `${mins} mins remaining`;
          } else {
            const mm = Math.floor(timeLeft / 60000).toString().padStart(2, '0');
            const ss = Math.floor((timeLeft % 60000) / 1000).toString().padStart(2, '0');
            label.textContent = `${mm}:${ss}`;
          }
        }
      }
    };

  // Store the start time in localStorage to handle tab switches
  localStorage.setItem('refresh_start_time', updateState.startTime.toString());
  localStorage.setItem('current_workflow_update', JSON.stringify({ project, timestamp: updateState.startTime }));

    // Ensure we persist and reuse start time across tabs
    const storedStart = parseInt(localStorage.getItem('refresh_start_time'));
    if (storedStart && (Date.now() - storedStart) < updateState.totalTime) {
      updateState.startTime = storedStart;
    } else {
      localStorage.setItem('refresh_start_time', updateState.startTime.toString());
    }

    // Start time update interval (time-based progress to align with countdown)
    updateState.timer = setInterval(() => {
      const storedStartTime = parseInt(localStorage.getItem('refresh_start_time')) || updateState.startTime;
      const elapsed = Date.now() - storedStartTime;
      const timeLeft = Math.max(0, updateState.totalTime - elapsed);
      const percentTime = Math.min(100, (elapsed / updateState.totalTime) * 100);

      if (timeLeft <= 0 && !updateState.isCompleted) {
        clearInterval(updateState.timer);
        window.location.reload();
        return;
      }

  // Update message based on elapsed time so each message shows for ~30s
  const elapsedForMsg = elapsed; // ms
  const idx = Math.floor(elapsedForMsg / 30000); // 30s per message
  const messageIndex = Math.min(updateMessages.length - 1, idx);
  updateProgress(percentTime, updateMessages[messageIndex], timeLeft);
    }, 1000);

    try {
      // Check if token exists
      if (!WORKFLOW_PAT_NEW || WORKFLOW_PAT_NEW === '${{ secrets.WORKFLOW_PAT_NEW }}') {
        throw new Error('GitHub token not properly configured');
      }

      // Clean and validate project name
      const fullProjectName = (typeof project === 'string') ? project.replace(/^\s+|\s+$/g, '').replace(/^['"]|['"]$/g, '') : project;
      if (fullProjectName !== 'VM 13.0' && fullProjectName !== 'Blaze 1.0' && fullProjectName !== 'VM 14.0') {
        throw new Error(`Invalid project name: ${fullProjectName}`);
      }

  // Initialize workflow (start at 0% to match full 10-minute timer)
  updateProgress(0, 'Initializing workflow...', updateState.totalTime);
      
      // Use workflow file dispatch to target update-dashboards.yml directly
      updateState.dispatchTime = Date.now();
      const response = await fetch('https://api.github.com/repos/Abhinav-PIC/NPI-Dashboards/actions/workflows/update-dashboards.yml/dispatches', {
        method: 'POST',
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          'Authorization': `token ${WORKFLOW_PAT_NEW}`,
          'Content-Type': 'application/json',
          'X-GitHub-Api-Version': '2022-11-28'
        },
        body: JSON.stringify({
          ref: 'main',
          inputs: {
            project: fullProjectName
          }
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('GitHub API Error:', {
          status: response.status,
          statusText: response.statusText,
          error: errorText
        });
        throw new Error(`GitHub API Error: ${response.status} - ${errorText || response.statusText}`)
      }

  updateProgress(5, 'Installing dependencies...', updateState.totalTime);

      let lastWorkflowStatus = '';
      // Store workflow ID in localStorage to track refresh
      const workflowKey = 'current_workflow_update';
      
  // Record dispatch timestamp so we can match the created run
  updateState.dispatchTime = Date.now();

  // Poll for completion
  for (let i = 0; i < 120; i++) { // poll up to 10 minutes (120 * 5s)
        await new Promise(r => setTimeout(r, 5000));
        // compute local elapsed/timeLeft/percent so UI is consistent and timer-driven
        const elapsedLocalPre = Date.now() - updateState.startTime;
        const timeLeftPre = Math.max(0, updateState.totalTime - elapsedLocalPre);
        const percentTimePre = Math.min(100, (elapsedLocalPre / updateState.totalTime) * 100);
        // let the timer-driven UI handle messages; only update progress value here
        updateProgress(percentTimePre, null, timeLeftPre);
        try {
          // List recent workflow runs (workflow_dispatch events)
          const response = await fetch(
            'https://api.github.com/repos/Abhinav-PIC/NPI-Dashboards/actions/runs?event=workflow_dispatch&per_page=20',
            {
              headers: {
                'Accept': 'application/vnd.github.v3+json',
                'Authorization': `token ${WORKFLOW_PAT_NEW}`
              }
            }
          );
          
          if (!response.ok) {
            throw new Error('Failed to fetch workflow status');
          }

          const { workflow_runs } = await response.json();

          if (!workflow_runs || !workflow_runs.length) {
            // no runs yet; let the timer handle message rotation and progress
            continue;
          }

          // Try to find the run that was created after our dispatch time (workflow_dispatch)
          const candidate = workflow_runs.find(r => {
            try {
              const created = new Date(r.created_at).getTime();
              return created >= (updateState.dispatchTime - 30000) && r.event === 'workflow_dispatch';
            } catch (e) {
              return false;
            }
          }) || workflow_runs[0];

          const run = candidate;
          const status = run.status;
          
          // Store workflow run ID and status
          localStorage.setItem(workflowKey, JSON.stringify({ id: run.id, status: status, conclusion: run.conclusion, project: fullProjectName, timestamp: Date.now() }));
          // Keep runId in state so cancel can reference it
          updateState.runId = run.id;

          // Check for cancellation or failure
          if (status === 'completed') {
            if (run.conclusion === 'cancelled') {
              throw new Error('Update cancelled');
            } else if (run.conclusion === 'failure') {
              throw new Error('Update failed');
            }
          }

          // Get total dashboard count based on project
          const dashboardCount = fullProjectName === 'VM 14.0' ? 7 : 
                               fullProjectName === 'VM 13.0' ? 5 : 
                               fullProjectName === 'Blaze 1.0' ? 4 : 0;
          
          // Keep UI strictly time-driven for smoothness: progress is percentTime (from interval)
          // Choose a friendly message based on status but don't let workflow step heuristics jump the bar
          const uiMessage = status === 'in_progress' ? 'Updating dashboards...' :
                            status === 'queued' ? 'Waiting for workflow to start...' :
                            status === 'completed' && run.conclusion === 'success' ? 'Update complete!' : 'Processing...';

          // Use timer-driven percent so UI remains smooth; do not override messages here
          const elapsedLocal = Date.now() - updateState.startTime;
          const timeLeftLocal = Math.max(0, updateState.totalTime - elapsedLocal);
          const percentTimeLocal = Math.min(100, (elapsedLocal / updateState.totalTime) * 100);

          updateProgress(percentTimeLocal, null, timeLeftLocal);

          if (status === 'completed' && run.conclusion === 'success') {
            updateState.isCompleted = true;
            localStorage.removeItem(workflowKey);
            updateProgress(100, 'Update completed successfully!', 0);
            // remove start tracking
            localStorage.removeItem('refresh_start_time');
            clearInterval(updateState.timer);
            
            // Re-enable refresh buttons before reload
            document.querySelectorAll('.refresh-button').forEach(btn => {
              btn.classList.remove('disabled');
            });
            
            // Re-enable export buttons before reload
            document.querySelectorAll('.export-button').forEach(btn => {
              btn.classList.remove('disabled');
              btn.style.pointerEvents = 'auto';
            });
            
            // Re-enable edit buttons before reload
            document.querySelectorAll('.edit-button').forEach(btn => {
              btn.classList.remove('disabled');
              btn.style.pointerEvents = 'auto';
            });
            
            setTimeout(() => window.location.reload(), 2000);
            return;
          }

        } catch (error) {
          console.error('Error checking workflow status:', error);
          handleUpdateError('Failed to check workflow status');
        }
      }
  // If we get here, we've timed out
  handleUpdateError('Update timed out');
  // attempt to cleanup stored keys
  localStorage.removeItem('refresh_start_time');

    } catch (error) {
      console.error('Error:', error);
      handleUpdateError(error.message);
    }
  }

  function handleUpdateError(errorMessage) {
    const statusBox = document.getElementById('refresh-status');
    const messageEl = statusBox.querySelector('.status-message');
    const statusFooter = statusBox.querySelector('.status-footer');
    const progressBar = statusBox.querySelector('.progress-bar');
    const timeRemaining = statusBox.querySelector('.time-remaining');

    // Clear any existing intervals
    clearInterval(updateState?.timer);

    // Clear the workflow storage
    localStorage.removeItem('current_workflow_update');
    
    // Update UI to show error
    messageEl.textContent = '⚠️ Update Failed';
    statusFooter.textContent = errorMessage;
    progressBar.style.width = '100%';
    progressBar.style.background = '#ff6b6b';
    timeRemaining.style.display = 'none';

    // Re-enable refresh buttons
    document.querySelectorAll('.refresh-button').forEach(btn => {
      btn.classList.remove('disabled');
    });
    
    // Re-enable export buttons
    document.querySelectorAll('.export-button').forEach(btn => {
      btn.classList.remove('disabled');
      btn.style.pointerEvents = 'auto';
    });
    
    // Re-enable edit buttons
    document.querySelectorAll('.edit-button').forEach(btn => {
      btn.classList.remove('disabled');
      btn.style.pointerEvents = 'auto';
    });

    // Make status box dismissible
    statusBox.onclick = () => {
      statusBox.classList.remove('active');
      progressBar.style.background = 'var(--philips)';
      timeRemaining.style.display = 'block';
    };

    // Auto-hide after 10 seconds
    setTimeout(() => {
      statusBox.classList.remove('active');
      progressBar.style.background = 'var(--philips)';
      timeRemaining.style.display = 'block';
    }, 12000);
  }

  // Add page visibility and storage change handling
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      // Don't auto-restart if we already have a running update in this tab
      if (updateState && !updateState.isCompleted) return;
      const workflowData = localStorage.getItem('current_workflow_update');
      if (workflowData) {
        try {
          const { project, timestamp } = JSON.parse(workflowData);
          // Only resume if the update is less than 10 minutes old
          if (Date.now() - timestamp < 600000) {
            refreshDashboards(project);
          } else {
            localStorage.removeItem('current_workflow_update');
          }
        } catch (e) {
          localStorage.removeItem('current_workflow_update');
        }
      }
    }
  });

  function showToast(message, duration = 5000) {
    let toast = document.querySelector('.toast-notification');
    if (!toast) {
      toast = document.createElement('div');
      toast.className = 'toast-notification';
      document.body.appendChild(toast);
    }
    
    toast.textContent = message;
    toast.classList.add('show');
    
    setTimeout(() => {
      toast.classList.remove('show');
    }, duration);
  }

  // Make status box draggable
  function makeDraggable(element) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    const header = element.querySelector('.status-header');
    
    if (header) {
      header.onmousedown = dragMouseDown;
    } else {
      element.onmousedown = dragMouseDown;
    }

    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      // get the mouse cursor position at startup
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      // call a function whenever the cursor moves
      document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      // calculate the new cursor position
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      // set the element's new position
      const newTop = (element.offsetTop - pos2);
      const newLeft = (element.offsetLeft - pos1);
      
      // Keep within viewport bounds
      const maxX = window.innerWidth - element.offsetWidth;
      const maxY = window.innerHeight - element.offsetHeight;
      
      element.style.top = Math.min(maxY, Math.max(0, newTop)) + "px";
      element.style.left = Math.min(maxX, Math.max(0, newLeft)) + "px";
      element.style.right = 'auto';
    }

    function closeDragElement() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  }

  // Initialize draggable status box
  const statusBox = document.getElementById('refresh-status');
  if (statusBox) makeDraggable(statusBox);

  // Cancel update logic
  async function cancelUpdate() {
    if (!updateState) return;

    // Hide UI immediately
    document.getElementById('refresh-status').classList.remove('active');
    document.querySelectorAll('.refresh-button').forEach(btn => btn.classList.remove('disabled'));
    
    // Re-enable export buttons when refresh is cancelled
    document.querySelectorAll('.export-button').forEach(btn => {
      btn.classList.remove('disabled');
      btn.style.pointerEvents = 'auto';
    });
    
    // Re-enable edit buttons when refresh is cancelled
    document.querySelectorAll('.edit-button').forEach(btn => {
      btn.classList.remove('disabled');
      btn.style.pointerEvents = 'auto';
    });

    // Try to determine runId if not present
    let runId = updateState.runId;
    if (!runId) {
      try {
        const resp = await fetch('https://api.github.com/repos/Abhinav-PIC/NPI-Dashboards/actions/runs?event=workflow_dispatch&per_page=20', {
          headers: { 'Accept': 'application/vnd.github.v3+json', 'Authorization': `token ${WORKFLOW_PAT_NEW}` }
        });
        if (resp.ok) {
          const data = await resp.json();
          const runs = data.workflow_runs || [];
          const candidate = runs.find(r => {
            const created = new Date(r.created_at).getTime();
            return created >= (updateState.dispatchTime - 30000);
          });
          if (candidate) runId = candidate.id;
        }
      } catch (e) {
        console.error('Failed to lookup run id for cancel', e);
      }
    }

    if (!runId) {
      showToast('No workflow run found to cancel');
      updateState = null;
      localStorage.removeItem('current_workflow_update');
      localStorage.removeItem('refresh_start_time');
      return;
    }

    try {
      // Call the cancel endpoint for a workflow run
      const resp = await fetch(`https://api.github.com/repos/Abhinav-PIC/NPI-Dashboards/actions/runs/${runId}/cancel`, {
        method: 'POST',
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          'Authorization': `token ${WORKFLOW_PAT_NEW}`
        }
      });

      if (!resp.ok) {
        const text = await resp.text();
        throw new Error('Cancel failed: ' + (text || resp.statusText));
      }

      localStorage.removeItem('current_workflow_update');
      localStorage.removeItem('refresh_start_time');
      updateState = null;
      showToast('Update cancelled');
    } catch (e) {
      console.error('Cancel error', e);
      showToast('Failed to cancel workflow');
    }
  }

  // Wire cancel button
  const cancelBtn = document.getElementById('cancel-update');
  if (cancelBtn) cancelBtn.addEventListener('click', (e) => { e.stopPropagation(); cancelUpdate(); });

  // Listen for storage changes in other tabs
  window.addEventListener('storage', (e) => {
    if (e.key === 'current_workflow_update') {
      if (!e.newValue) {
        // Update was completed or cancelled in another tab
        window.location.reload();
      }
    }
  });

  // Show notification when returning to tab if update completed
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      const workflowData = localStorage.getItem('current_workflow_update');
      if (!workflowData && document.querySelector('.refresh-status.active')) {
        showToast('Dashboard update completed! Refreshing page...');
        setTimeout(() => window.location.reload(), 2000);
      }
    }
  });
</script>

</body>
</html>
